#PS6P02 Arnold Christopher Koroa A0092101Y

# The Translation scheme:
#   The generator will accept the same number of arguments as
#   its haskell counterpart. If the argument is a list, however,
#   the phyton generator will accept a function that generates
#   the list instead of the list itself.
#
#   The generator will define a return function (the handler)
#   and returns it
#
#   The return function is defined as follows:
#       The function will yield the function applied to the head
#       of the list argument(s)
#
#       The function then recursively calls the generator, passing the
#       argument function, and the tail of the list arguments as the
#       argument to the recursive call
#
#       The function will then yield values generated by the handler
#       returned by the recursive call one by one

def tail(g): # no haskell equivalent since no pattern matching
    def p():
        h = g()
        next(h)
        for x in h:
            yield x
    return p

def head(g): # no haskell equivalent since no pattern matching
    return next(g())

# haskell: zipWith z la lb = (z (head la) (head lb)) :
#                               (zipWith z (tail la) (tail lb))
def zipWithGen(f,g,h):
    def rets():
        yield f(head(g),head(h))
        for x in zipWithGen(f,tail(g),tail(h))(): yield x
    return rets

# haskell: fib = 0:1:(zipWith (+) fib (tail fib))
def fib():
    yield 0
    yield 1
    h = zipWithGen(lambda x,y:x+y,fib,(tail(fib)))()
    for x in h: yield x
